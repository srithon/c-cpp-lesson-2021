#+TITLE: C Lesson
* Explicit Pointers
[[./media/pointers-in-c.png]]

** Java
*** Pass by Value
#+begin_src java :classname Foo
public class Foo {
    static void increment_int(int int_argument) {
        int_argument++;
    }

    public static void main(String[] args) {
        int i = 0;
        System.out.println("int BEFORE incrementing = " + i);

        increment_int(i);
        System.out.println("int AFTER incrementing = " + i);
    }
}
#+end_src

#+RESULTS:
: int BEFORE incrementing = 0
: int AFTER incrementing = 0
*** Pass by Reference
#+begin_src java :classname Foo
public class Foo {
    static class MutableInt {
        int int_field;

        public String toString() { return "" + int_field; }
    }

    static void increment_mutable_int(MutableInt int_argument) {
        int_argument.int_field++;
    }

    public static void main(String[] args) {
        MutableInt integer = new MutableInt();
        System.out.println("int BEFORE incrementing = " + integer);

        increment_mutable_int(integer);
        System.out.println("int AFTER incrementing = " + integer);
    }
}
#+end_src

#+RESULTS:
: int BEFORE incrementing = 0
: int AFTER incrementing = 1

** C

#+begin_src C :results output
#include <stdio.h>

void increment_int(int *int_argument) {
    *int_argument = *int_argument + 1;
    // (*int_argument)++;
}

int main() {
    int i = 0;
    printf("i = %d\n", i);

    int *i_ptr = &i;
    printf("i_ptr = %p\n", i_ptr);

    increment_int(i_ptr);

    printf("dereferenced i_ptr = %d\n", *i_ptr);
    printf("i = %d\n", i);
}
#+end_src

#+RESULTS:
: i = 0
: i_ptr = 0x7fff974e5664
: dereferenced i_ptr = 1
: i = 1

*** Multiple Declarations
#+begin_src C :results output :tangle "code/multi_declaration_ptr.c"
#include <stdio.h>

int main() {
    int i = 1,
        j = 2;

    int* i_ptr = &i,
     // *j_ptr = &j;
         j_ptr = &j;

    printf("i: %p, j: %p", i_ptr, j_ptr);
}
#+end_src

#+RESULTS:
: i: 0x7ffe33997db0, j: 0x33997dac

**** gcc
With ~gcc~, this is only a warning by default
[[./media/multi_declaration_ptr_warning_gcc.png]]
**** g++
With ~g++~ (the ~C++~ compiler), this throws an error by default
[[./media/multi_declaration_ptr_error_g++.png]]

* Stack vs Heap Allocation
** Stack
See [[https://stackoverflow.com/a/13888303]]
*** With Static
#+begin_src C :results output :tangle code/stack.c
#include <stdio.h>

static int *i_ptr;

void assign_i_ptr() {
    int i = 10;
    i_ptr = &i;
}

void stack_allocate_another_int() {
    int b = 30;
}

int main() {
    assign_i_ptr();
    printf("*i_ptr = %d\n", *i_ptr);

    stack_allocate_another_int();
    printf("*i_ptr = %d", *i_ptr);
}
#+end_src

#+RESULTS:
: *i_ptr = 10
: *i_ptr = 30

*** Without Static
#+begin_src C :results output :tangle code/stack.c
#include <stdio.h>

void assign_i_ptr(int **i_ptr_ptr) {
    int i = 10;
    *i_ptr_ptr = &i;
}

void stack_allocate_another_int() {
    int b = 30;
}

int main() {
    int *i_ptr = NULL;

    assign_i_ptr(&i_ptr);
    printf("*i_ptr = %d\n", *i_ptr);

    stack_allocate_another_int();
    printf("*i_ptr = %d", *i_ptr);
}
#+end_src

#+RESULTS:
: *i_ptr = 10
: *i_ptr = 30

** Heap
#+begin_src C :results output :tangle code/heap.c
#include <stdio.h>
#include <stdlib.h>

static int *i_ptr;

void assign_i_ptr() {
    int *allocated_memory = malloc(sizeof(int));
    *allocated_memory = 10;
    i_ptr = allocated_memory;
}

void heap_allocate_another_int() {
    int *allocated_memory = malloc(sizeof(int));
    *allocated_memory = 100;
}

void stack_allocate_another_int() {
    int b = 30;
}

int main() {
    assign_i_ptr();
    printf("*i_ptr = %d\n", *i_ptr);

    stack_allocate_another_int();
    heap_allocate_another_int();

    printf("*i_ptr = %d", *i_ptr);

    free(i_ptr);
}
#+end_src

#+RESULTS:
: *i_ptr = 10
: *i_ptr = 10

*** Memory Leak
#+begin_src shell :results output
gcc code/heap.c -o code/heap_binary
valgrind --leak-check=full code/heap_binary 2>&1 > /dev/null
#+end_src

#+RESULTS:
#+begin_example
==240221== Memcheck, a memory error detector
==240221== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==240221== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
==240221== Command: code/heap_binary
==240221==
==240221==
==240221== HEAP SUMMARY:
==240221==     in use at exit: 4 bytes in 1 blocks
==240221==   total heap usage: 3 allocs, 2 frees, 4,104 bytes allocated
==240221==
==240221== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==240221==    at 0x484086F: malloc (vg_replace_malloc.c:380)
==240221==    by 0x401185: heap_allocate_another_int (in /home/sridaran/notes/cpp/robotics-workshop/code/heap_binary)
==240221==    by 0x4011E0: main (in /home/sridaran/notes/cpp/robotics-workshop/code/heap_binary)
==240221==
==240221== LEAK SUMMARY:
==240221==    definitely lost: 4 bytes in 1 blocks
==240221==    indirectly lost: 0 bytes in 0 blocks
==240221==      possibly lost: 0 bytes in 0 blocks
==240221==    still reachable: 0 bytes in 0 blocks
==240221==         suppressed: 0 bytes in 0 blocks
==240221==
==240221== For lists of detected and suppressed errors, rerun with: -s
==240221== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
#+end_example

* No Garbage Collection/Reference Counting
** C
#+begin_src C :tangle code/HeapOverflow.c :results output :noweb yes
#include <sys/resource.h>
void limit_memory() {
    struct rlimit memory_limit = {
        // set soft and hard caps to 3 MB
        1024 * 1024 * 3,
        1024 * 1024 * 3
    };

    setrlimit(RLIMIT_AS, &memory_limit);
}

#include <stdio.h>
#include <stdlib.h>
int main() {
    limit_memory();

    for (int i = 0; i < 10000; i++) {
        void *ptr = malloc(10000 * sizeof(int));

        if (ptr == NULL) {
            printf("Ran out of memory at i = %d!\n", i);
            break;
        }

        printf("%d: %p\n", i, ptr);

        // free(ptr);
    }
}
#+end_src

#+RESULTS:
#+begin_example
0: 0x18a42a0
1: 0x18aef00
2: 0x18b8b50
3: 0x18c27a0
4: 0x18cc3f0
5: 0x18d6040
6: 0x18dfc90
7: 0x18e98e0
8: 0x18f3530
9: 0x18fd180
10: 0x1906dd0
11: 0x1910a20
12: 0x191a670
13: 0x19242c0
14: 0x192df10
15: 0x1937b60
16: 0x19417b0
17: 0x194b400
18: 0x1955050
Ran out of memory at i = 19!
#+end_example
** Java
#+begin_src java
public class MemoryLeak {
    static void heapAllocateBigArray() {
        int[] array = new int[10000];
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10_000; i++) {
            heapAllocateBigArray();
        }
    }
}
#+end_src

#+begin_src shell
javac code/MemoryLeak.java
cd code
valgrind java MemoryLeak 2>&1 > /dev/null
#+end_src
* [[https://stackoverflow.com/questions/25432371/how-can-one-emulate-the-c-namespace-feature-in-a-c-code][No Explicit Namespaces]]
* Preprocessor (Header Files)
** Problem
- ~header1.h~
  #+begin_src C :tangle code/c_project/problem/header1.h :main no
  #include <stdio.h>

  void print_something() {
      printf("something");
  }
  #+end_src
- ~header2.h~
  #+begin_src C :tangle code/c_project/problem/header2.h :main no
  #include "header1.h"

  void print_something_twice() {
      print_something();
      print_something();
  }
  #+end_src
- ~main.c~
  #+begin_src C :tangle code/c_project/problem/main.c
  #include "header1.h"
  #include "header2.h"

  int main() {
      print_something();
  }
  #+end_src

#+begin_src shell
cd code/c_project/problem
make main
#+end_src

#+RESULTS:
[[./media/c_lesson_error.png]]
** Solution
Use *header guards*

- ~header1.h~
  #+begin_src C :tangle code/c_project/solution/header1.h :main no
  #ifndef HEADER_1
  #define HEADER_1

  #include <stdio.h>

  void print_something() {
      printf("something");
  }

  #endif
  #+end_src
- ~header2.h~
  #+begin_src C :tangle code/c_project/solution/header2.h :main no
  #ifndef HEADER_2
  #define HEADER_2
  #include "header1.h"

  void print_something_twice() {
      print_something();
      print_something();
  }

  #endif
  #+end_src
- ~main.c~
  #+begin_src C :tangle code/c_project/solution/main.c
  #include "header1.h"
  #include "header2.h"

  int main() {
      print_something();
  }
  #+end_src

#+begin_src shell
cd code/c_project/solution
make main > /dev/null
./main
#+end_src

#+RESULTS:
: something
